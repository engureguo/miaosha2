# second kill

简单的秒杀系统



---



- `notes\` 笔记
  1. [分布式会话及登录功能 01](notes/01登录.md)、 [分布式会话及登录功能 02](notes/02分布式会话.md)
  2. [秒杀功能（基本功能）](notes/03秒杀.md)
  3. [简单压测](notes/04压测.md)
  4. [页面优化](notes/05RabbitMQ学习.md)
  5. [RabbitMQ学习](notes/05RabbitMQ学习.md)、[服务接口优化](notes/06服务优化.md)
  6. [安全优化](notes/07安全优化.md)
  7. [主流的秒杀方案]()
  8. [总结]()




---

### 1、分布式会话-登录功能总结

0、两次 md5 加密

1、一开始通过参数传递 mobile、password 需要对参数进行判断和校验

2、使用 @Valid 进行参**数校验**，以及自定义参数校验

3、校验失败时有异常，进行**全局异常处理**

4、**分布式 session** 问题，两种方式

5、每一个接口都需要做参数的校验，自定义 **用户参数** ，==在 controller 入口之前就做好了一层校验==



### 2、秒杀功能（基本功能）

0、四张表，独立出秒杀表

1、秒杀商品列表页 -> 商品详情页 -> 秒杀 -> 秒杀订单页/秒杀失败页

- 秒杀倒计时
- 秒杀前提：库存、限制秒杀次数




### 3、系统简单压测
0、jmeter。添加 cookie、自定义变量、请求参数

1、接口压测：

列表接口：读取商品的接口，与用户关联不大

秒杀接口：设计数据库读写，吞吐量明显比列表接口测试的小

出现的问题：商品超卖

> 两个平台上都进行压测，太麻烦，只在 windows 平台进行测试



### 4、页面优化总结

0、页面缓存（也是URL缓存）、和对象缓存（之前分布式 session 用过）

1、页面静态化，包括 商品详情、秒杀、订单详情，了解了一部分缓存配置。

好处：将静态页面缓存在浏览器，服务器只传输数据

2、库存超卖问题。SQL减库存、索引拦截方案、redis缓存



### 5、服务接口优化

中心思想：减少数据库（Redis 和 MySQL）的访问

<img src="https://i.loli.net/2021/08/21/X5vNMgWjbl1ft7U.png" alt="image-20210821192722826" style="zoom:80%;" />

0、RabbitMQ安装、常见模式的使用，重点是 topic 模式

1、Redis 预减库存：先在 Redis 中先减少库存，再在 MySQL 中实际减少，好处：减少 MySQL 访问压力

2、内存标记，减少 Redis 的访问

3、将秒杀消息放入队列后，立即返回。客户端使用 **轮询**的方法查询秒杀结果

4、消费者从 队列取出秒杀信息，进行**一系列判断**后，进行**真正的减库存和生成订单**

压测QPS：

<img src="https://i.loli.net/2021/08/21/vGASbgtMPsjXwq6.png" alt="image-20210821195352442" style="zoom:80%;" />

注意：使用客户端的 lua 脚本进行预减库存，增加了网络传输量，拉低了QPS（上图结果没有使用 lua 脚本进行预减库存）；实际接口是 `/seckill/doSeckill2`



### 6、安全优化 · 总结

0、前端优化不保险

1、接口地址隐藏，秒杀时需要获取真正的秒杀地址，可以防止一部分人

2、加入复杂的验证码（OCR技术的成熟），另一方面可以分散秒杀前几秒的压力

3、接口限流，有计数器算法、令牌桶算法、漏桶算法。使用拦截器做限流优化



### 7、主流的秒杀方案



1. 刷接口，黑客和黄牛
2. 超卖问题



预约限购：先统计参与秒杀的用户数，给用户发送抢购的token保存在浏览器本地，选择性展示抢购动画



网关和令牌桶进行限流：黑名单，ip地址、用户id



100万请求在 2s 内打到10台服务器，20万商品，80万不能触碰下单服务，在网关处终结 80w 的请求

可以使用令牌桶，有20个网关，每个网关承担 5w 个请求

**每个 tomcat 在不做复杂计算和数据库操作的情况下能做到一两千QPS**

每个网关可以开 1.5w个令牌桶，得不到令牌的直接返回失败，不会到后边的下单服务和队列

拿到令牌桶的请求，进入到下单的服务，这一步需要用最快的速度生成订单，mysq 是指望不上的

**mysql 每秒 2000 的写入很困难，即使是集群，想要达到上万级别的写入也很困难**

**订单写入 redis** （一方面速度快，另一方面考虑用户要频繁查询订单），还可以考虑 **redis 分片**，将不同用户的订单下入到不同的 redis

下单到 redis 还没有入库，入库的时候**使用 mq 进行流量削峰**，后端从 mq 中慢慢消费，做一些耗时的入库操作、分布式事务等等

20w个商品给 30w个令牌，可能会有超卖，防止超买，可以使用**分布式锁**，使用 redision

商品量少，几千几百个性能还行，每个下单处理耗时：redis 加锁和释放锁的时间 + 下单时间

数据量大了，比如**几十万**，就很麻烦

对**商品数量进行分片**，比如一个分布式锁只放 500 个商品数量，比如 goodsId-10-1,goodsId-10-2,goodsId-10-3,,,，使用 hash 将分布式锁放到不同的 key 上，复杂，不好控制不同余量的消耗

可以在服务器实例写好商品数量，**在内存中判断**，使用 Apollo 和 Nacos 进行配置

可以少买但是不能超卖



### 8、总结

1. 项目框架搭建。
   1. springboot 集成 thymeleaf
   2. 统一返回 respBean
   3. mybatis
2. 分布式会话
   1. 用户登录：设计数据库，明文密码二次md5加密，参数校验+全局异常处理
   2. 共享session：SpringSession、redis

3. 功能开发
   1. 商品列表、商品详情、秒杀、订单详情
4. 系统压测
   1. jmeter：自定义变量模拟多用户、jmeter命令行使用
   2. 压测：商品列表、秒杀

5. 优化
   1. 页面优化：页面缓存、对象缓存、页面静态化（前后端分离），静态资源优化、cdn优化
   2. 接口优化：redis预减库存减少数据库访问、内存标记减少redis访问，rabbitmq异步下单
   3. rabbitmy：与springboot整合、交换机
6. 安全优化
   1. 秒杀接口隐藏
   2. 算术验证码
   3. 接口防刷，通用接口限流
7. 主流的秒杀方案



写代码思路：不实单纯地写代码，做到更好的封装和优化	





