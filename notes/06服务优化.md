

### redis 预减库存

实现 **InitializingBean** 接口， 在项目启动时将秒杀商品信息存放至 redis 中

```java
@Controller
@RequestMapping("/seckill")
public class SeckillController implements InitializingBean {
 
    /**
     * 项目启动，将秒杀商品信息存入 redis，主要是 商品id和库存量
     */
    @Override
    public void afterPropertiesSet() {
        List<GoodsVo> allGoodsVo = goodsService.findAllGoodsVo();

        ValueOperations opsFV = redisTemplate.opsForValue();
        allGoodsVo.forEach(goodsVo -> opsFV.set("seckill:goodsVo-" + goodsVo.getId(), goodsVo.getStockCount()));

    }
    
}
```

秒杀接口

```java
@RequestMapping(value = "doSeckill2", method = RequestMethod.POST)
@ResponseBody
public RespBean kill2(User user, @RequestParam("goodsId") Long goodsId) {

    if (user == null)
        return RespBean.error(RespTypeEnum.SESSION_NOT_EXIST);

    ValueOperations opsFV = redisTemplate.opsForValue();

    //1) 从缓存中取“可能买过的记录”，可以拦截大部分的“二次购买”
    Object orderInfo = opsFV.get("seckOrder:userId-" + user.getId()
            + ":goodsId-" + goodsId);
    if (null != orderInfo) {
        return RespBean.error(RespTypeEnum.REPEATED_BUY_ERROR, orderInfo);
    }

    //2redis预减库存
    Long afterDecr = opsFV.decrement("seckill:goodsVo-" + goodsId);

    if (afterDecr == null) return RespBean.error(RespTypeEnum.GOODS_NOT_EXIST);

    if (afterDecr < 0) {
        opsFV.increment("seckill:goodsVo-" + goodsId);
        return RespBean.error(RespTypeEnum.OUT_OF_STOCK);
    }
    
    ...
}
```



### 集成 RabbitMQ

定义秒杀消息

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class SeckillMessage {
    private User user;
    private Long goodsId;
}
```

秒杀接口中，如果秒杀成功，将秒杀信息进行封装并转化成 字符串，放入队列，返回给用户消息，用户**轮询**查询结果

```java
//将秒杀信息放入消息队列
SeckillMessage seckillMessage = new SeckillMessage(user, goodsId);
mqSender.sendSeckillMessage(JsonUtil.object2JsonStr(seckillMessage));//obj2str

return RespBean.success(0);//“快速”将结果返回给用户
```

消息队列 routingkey

```java
@Bean
public Binding binding_routing_key() {
    return BindingBuilder.bind(seckillQueue()).to(seckillExchange()).with("seckill.#");
}
```

生产者

```java
public void sendSeckillMessage(String msg) {
    log.info("发送消息：" + msg);
    rabbitTemplate.convertAndSend(RabbitMQConfig.Seckill_Exchange, "seckill.message", msg);
}
```

消费者，调用业务代码，处理秒杀信息

```java
@RabbitListener(queues = RabbitMQConfig.Seckill_Queue)
public void receiveSeckillMessage(String message) {
    log.info(message);
    SeckillMessage seckillMessage = JsonUtil.jsonStr2Object(message, SeckillMessage.class);
    User user = seckillMessage.getUser();
    Long goodsId = seckillMessage.getGoodsId();
    GoodsVo goodsVo = goodsService.findGoodsVoByGoodsId(goodsId);

    // 库存的控制主要在 redis，实际上进行 mysql 中库存的更新
    if (goodsVo.getStockCount() < 1) {
        return;
    }

    ValueOperations opsFV = redisTemplate.opsForValue();
    //重复抢购
    Object orderInfo = opsFV.get("seckOrder:userId-" + user.getId()
            + ":goodsId-" + goodsId);
    if (null != orderInfo) {
        return;
    }

    orderService.seckill(user, goodsVo);//扣除秒杀商品库存、生成订单
}
```



### 内存标记

问题：大量请求访问 redis，压力过大，在 jvm 中使用一个变量进行标记，可以很大程度上减少 redis 的访问次数

```java
//内存标记，减少 redis 的访问
private Map<Long, Boolean> goodsIsEmptyMap = new HashMap<>();


@RequestMapping(value = "doSeckill2", method = RequestMethod.POST)
@ResponseBody
public RespBean kill2(User user, @RequestParam("goodsId") Long goodsId) {

    if (user == null)
        return RespBean.error(RespTypeEnum.SESSION_NOT_EXIST);

    //在进行秒杀业务之前，先判断一个变量的标志，这个变量标记这个商品是否买完
    if (goodsIsEmptyMap.get(goodsId)) {
        return RespBean.error(RespTypeEnum.OUT_OF_STOCK);
    }

    ...
    
    // redis预减库存
    Long afterDecr = opsFV.decrement("seckill:goodsVo-" + goodsId);
    if (afterDecr == null)
        return RespBean.error(RespTypeEnum.GOODS_NOT_EXIST);

    if (afterDecr < 0) {
        goodsIsEmptyMap.put(goodsId, true);//标记该秒杀商品已经售罄
        opsFV.increment("seckill:goodsVo-" + goodsId);
        return RespBean.error(RespTypeEnum.OUT_OF_STOCK);
    }
    
    ...
}

/**
 * 项目启动，初始化商品信息
 */
@Override
public void afterPropertiesSet() {
    List<GoodsVo> allGoodsVo = goodsService.findAllGoodsVo();

    ValueOperations opsFV = redisTemplate.opsForValue();
    allGoodsVo.forEach(goodsVo -> {
                opsFV.set("seckill:goodsVo-" + goodsVo.getId(), goodsVo.getStockCount());
                goodsIsEmptyMap.put(goodsVo.getId(), false);//标记各种商品为false，表示不空
            }
    );

}

```







